<h1 align="center"><strong>AC supply management by STM32 [on schedule]</strong></h1>


<p><i>English version coming soon. Let me finish russian version :)</i></p>


<h1 align="center"><strong>Управление внешней нагрузкой с микроконтроллера [по расписанию]</strong></h1>


Допустим, есть внешний потребитель энергии и микроконтроллер.
[картинка, на которой отдельно потребитель, отдельно микроконтроллер]

Задача: с помощью микроконтроллера разрешать и запрещать пользоваться энергией потребителю.

Решение: электрическая схема между микроконтроллером и потребителем + программа для микроконтроллера.
[картинка, на которой потребитель и микроконтроллер связаны]


<h2 align="center">Электрическая схема</h2>
Я выбрал схему с оптроном, она обеспечивает гальваническую развязку управляющей цепи и цепи потребителя. Схема взята из даташита на оптосимистор MOC3023[ссылка].
[скриншот]
Порт микроконтроллера, соединённый с оптроном, работает в режиме открытого стока. Для ограничения тока оптрона последовательно включен резистор, сопротивлением [Ом].
Микроконтроллер: STM32F303VCT6.
Плата STM32F3Discovery.


<h2 align="center">Программа</h2>
<h3>Алгоритм</h3>
Для открытия оптрона необходимо подать ток, для этого можно использовать любой GPIO вывод. Я использовал таймер для открытия и закрытия оптрона через заданные промежутки времени. Алгоритм работы выглядит так:
[фото алгоритма]

<h3>Исходный код</h3>
CubeMX генерирует каркас приложения, поэтому в репозиторий включены только файлы, которые я изменял. Прокомментирую ключевые моменты:

<h4>main.h</h4>
В заголовочнике перечислены номера портов.
Порт для оптрона - PC1, порты светодиодов для индикации - по умолчанию, из CubeMX.

<h4>main.c</h4>
В массивах intervals_24_hour[] и intervals_primitive[] хранятся интервалы времени, на протяжении которых оптрон открыт и закрыт. Эти массивы представляют режимы работы.
Указатель *intervals_pointer указывает на текущий массив (режим работы).
Переменной index_of_interval можно задать, с какого интервала массива начать работу при старте микроконтроллера.

Перед основным циклом программы идёт инициализация периферии микроконтроллера, индикация включения и разрешение прерываний от таймера HAL_TIM_Base_Start_IT().

Так как состояний оптрона всего лишь два: открыт и закрыт, то в основном цикле программы интервалы меняются последовательно
```
if(minutes >= intervals_pointer[index_of_interval])
{
    ...
    index_of_interval++;
}
```
,
и состояние оптрона просто инвертируется вызовом функции HAL_GPIO_TogglePin().

Таймер настроен таким образом, что по истечении секунды происходит переполнение счётчика и генерируется прерывание. Прерывание вызывает функцию HAL_TIM_PeriodElapseCallback(), которая инкрементирует переменную seconds и мигает светодиодом.

Нажатие (точнее, последующее отпускание) пользовательской кнопки PA0 генерирует прерывание HAL_GPIO_EXTI_Callback() по линии 0, обработчик которого переключает режимы: указатель *intervals_pointer переключается на другой массив.
